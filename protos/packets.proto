syntax = "proto3";

package proto;

// The Sniffer service is responsible capturing data from a file or a network
// interface card and relaying the data to clients.
service Sniffer {
  // Create a sniffer instance
  rpc SnifferCreate(SnifferCreateRequest) returns (SnifferID) {}

  // Create a sniffer instance
  rpc SnifferDestroy(SnifferID) returns (Empty) {}

  // List active sniffers
  rpc SnifferList(Empty) returns (SnifferListResponse) {}

  // List sniffer files (pcap recordings of 802.11 networks)
  rpc SniffFileList(Empty) returns (SniffFileListResponse) {}

  // List interfaces that can be used for sniffing
  rpc SniffInterfaceList(Empty) returns (SniffInterfaceListResponse) {}

  // Get all discovered access points.
  rpc GetAllAccessPoints(SnifferID) returns (NetworkList) {}

  // Get a specific access point.
  rpc GetAccessPoint(NetworkName) returns (NetworkInfo) {}

  // Focus a specific network allowing for capture of more packets.
  rpc FocusNetwork(NetworkName) returns (Empty) {}

  // Get information whether any access point is being focused.
  rpc GetFocusState(SnifferID) returns (FocusState) {}

  // Stop focusing an access point.
  rpc StopFocus(SnifferID) returns (Empty) {}

  // Decryption & getting handshakes
  rpc ProvidePassword(DecryptRequest) returns (Empty) {}

  // Get the decrypted packets for an access point.
  rpc GetDecryptedPackets(NetworkName) returns (stream Packet) {}

  // Deauthenticate a client from a network.
  rpc DeauthNetwork(DeauthRequest) returns (Empty) {}

  // Ignore a specific network, it won't show up in the network list.
  rpc IgnoreNetwork(NetworkName) returns (Empty) {}

  // Get all the ignored networks.
  rpc GetIgnoredNetworks(SnifferID) returns (NetworkList) {}

  // Save the stream from a network to a file.
  rpc RecordingCreate(RecordingCreateRequest)
      returns (RecordingCreateResponse) {}

  // Get all recordings on disk, those can also be loaded with `LoadRecording`.
  rpc GetAvailableRecordings(Empty) returns (RecordingsList) {}

  // Load a specific network traffic recording.
  rpc LoadRecording(File) returns (stream Packet) {}

  // Enable mayhem mode, deauthenticating all clints from all networks.
  rpc SetMayhemMode(NewMayhemState) returns (Empty) {}

  // Enable the LED on the server and subscribe to the LED updates.
  rpc GetLED(SnifferID) returns (stream LEDState) {}
}

// Empty message, it exists since we can't send no arguments or receive no
// data
message Empty {}

// Specify the sniffer ID
message SnifferID { string uuid = 1; }

// Create a sniffer
message SnifferCreateRequest {
  bool is_file_based = 1;
  string net_iface_name = 2;
  string filename = 3;
}

// List many sniffers
message SnifferListResponse { repeated SnifferInfo sniffers = 1; }
message SnifferInfo {
  string uuid = 1;
  string name = 2;
  bool is_file_based = 3;
  string net_iface_name = 4;
  string filename = 5;
}

// List available files or logical interfaces
message SniffFileListResponse { repeated string filename = 1; }
message SniffInterfaceListResponse { repeated string net_iface_name = 1; }

// Network name denoted by its ssid
message NetworkName {
  string sniffer_uuid = 1;
  string ssid = 2;
}

// Netowrk data link layer types
enum DataLinkType {
  DOT11 = 0; // 802.11
  ETH2 = 1;  // Ethernet 2
}

// Create a recording
message RecordingCreateRequest {
  string sniffer_uuid = 1;
  bool singular_ap = 2;
  string ssid = 3;            // If singular_ap is true
  DataLinkType data_link = 4; // If data_link is set to 80211, we save raw
                              // non-decrypted traffic, otherwise try to decrypt
                              // traffic and then save it
}

message RecordingCreateResponse {
  int64 packet_count = 1; // Total packet count across all APs
}

// Add a user MAC to the deauth request
message DeauthRequest {
  string sniffer_uuid = 1;
  NetworkName network = 2;
  string user_addr = 3;
}

// List of networks
message NetworkList { repeated string names = 1; }

// Decryption request
message DecryptRequest {
  string sniffer_uuid = 1;
  string ssid = 2;
  string passwd = 3;
}

// Access Point information
message NetworkInfo {
  string bssid = 1;
  string name = 2;
  int64 channel = 3;
  int64 encrypted_packet_count = 4;
  int64 decrypted_packet_count = 5;
  repeated ClientInfo clients = 6;
}

// Information about a client which is connected to a particular WLAN
message ClientInfo {
  string addr = 1;
  bool is_decrypted = 2;
  int64 handshake_num = 3;
  bool can_decrypt = 4;
}

// Information about the focus state
message FocusState {
  bool focused = 1;
  NetworkName name =
      2; // This is optional, if we are NOT in focus mode this doesn't exist
}

// Information about a file
message File {
  string sniffer_uuid = 1;
  string name = 2;
}

// List of available recordings
message RecordingsList { repeated File files = 1; }

// Set mayhem (deauthing all networks)
message NewMayhemState {
  string sniffer_uuid = 1;
  bool state = 2;
}

// Color of the LED
enum Color {
  RED = 0;
  YELLOW = 1;
  GREEN = 2;
}

// Change LED state
message LEDState {
  bool state = 1;
  Color color = 2;
}

enum Protocol {
  PROTO_RAW = 0;
  PROTO_ARP = 1;
  PROTO_ICMP = 2;
  PROTO_ICMPv6 = 3;
  PROTO_DNS = 4;
  PROTO_DHCP = 5;
  PROTO_DHCPv6 = 6;
  PROTO_IP = 7;
  PROTO_IPv6 = 8;
  PROTO_TCP = 9;
  PROTO_UDP = 10;
}

message Raw { bytes payload = 1; }

message ARP {
  string sender_ip_address = 1;
  string sender_mac_address = 2;
  string target_ip_address = 3;
  string target_mac_address = 4;
}

message ICMP {
  enum Type {
    ECHO_REPLY = 0;
    DESTINATION_UNREACHABLE = 3;
    ECHO_REQUEST = 8;
    TIME_EXCEEDED = 11;
    OTHER = 12;
  }

  Type type = 1;
  uint32 code = 2;
}

message ICMPv6 {
  enum Type {
    NONE = 0;
    ECHO_REQUEST = 128;
    ECHO_REPLY = 129;
    DESTINATION_UNREACHABLE = 1;
    PACKET_TOO_BIG = 2;
    TIME_EXCEEDED = 3;
    PARAMETER_PROBLEM = 4;
    NEIGHBOR_SOLICITATION = 135;
    NEIGHBOR_ADVERTISEMENT = 136;
  }

  Type type = 1;
  uint32 code = 2;
  uint32 checksum = 3;
}

message DNS {
  uint32 id = 1;
  bool qr = 2; // Query/Response
  repeated Question questions = 3;
  repeated ResourceRecord answers = 4;

  message Question {
    string name = 1;
    uint32 type = 2;
  }

  message ResourceRecord {
    string name = 1;
    uint32 type = 2;
    string data = 3;
  }
}

message DHCP {
  uint32 message_type = 1;
  uint32 transaction_id = 2;
  string client_ip_address = 3;
  string your_ip_address = 4;
  string server_ip_address = 5;
  string client_mac_address = 6;
}

message DHCPv6 {
  uint32 message_type = 1;
  uint32 transaction_id = 2;
  repeated Option options = 3;

  message Option {
    uint32 option_code = 1;   // Option code indicating the type of option
    uint32 option_length = 2; // Length of the option data
    bytes option_data = 3;    // Option-specific data
  }
}

message IP {
  string source_address = 1;
  string destination_address = 2;
  uint32 ttl = 3;
  uint32 protocol = 4;
  uint32 total_length = 5;
  bytes payload = 6;
  Protocol next_protocol = 7; // Next protocol
  oneof next {
    ICMP icmp = 8;
    TCP tcp = 9;
    UDP udp = 10;
  };
}

message IPv6 {
  string source_address = 1;
  string destination_address = 2;
  uint32 hop_limit = 3;
  uint32 next_header = 4;
  uint32 payload_length = 5;
  bytes payload = 6;
  Protocol next_protocol = 7; // Next protocol
  oneof next {
    ICMPv6 icmpv6 = 8;
    TCP tcp = 9;
    UDP udp = 10;
  }
}

message TCP {
  uint32 source_port = 1;
  uint32 destination_port = 2;
  uint32 sequence_number = 3;
  uint32 acknowledgment_number = 4;
  uint32 window_size = 5;
  bool syn = 6;
  bool ack = 7;
  bool fin = 8;
}

message UDP {
  uint32 source_port = 1;
  uint32 destination_port = 2;
  Protocol next_protocol = 4;
  oneof next {
    DNS dns = 5;
    DHCP dhcp = 6;
    DHCPv6 dhcpv6 = 7;
  };
}

message Packet {
  string src = 1;        // MAC address of the sender
  string dst = 2;        // MAC address of the destnation
  Protocol protocol = 3; // Protocol of the message
  oneof data {
    Raw raw = 4;
    ARP arp = 5;
    ICMP icmp = 6;
    ICMPv6 icmpv6 = 7;
    DNS dns = 8;
    DHCP dhcp = 9;
    DHCPv6 dhcpv6 = 10;
    IP ip = 11;
    IPv6 ipv6 = 12;
    TCP tcp = 13;
    UDP udp = 14;
  };
}
